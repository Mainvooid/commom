<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>common: commom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">common
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__d_1_code_common_common__r_e_a_d_m_e.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">commom </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>common library only include header files.</p>
<p>It has only been tested on Windows.</p>
<hr/>
<h2>Tree</h2>
<div class="fragment"><div class="line">│  code.snippet     <span class="comment">//文件代码模板(vs-&gt;工具-&gt;代码片段管理中导入)</span></div><div class="line">│  <a class="code" href="namespacecommon.html">common</a>.hpp       <span class="comment">//主头文件(使用时include本文件)</span></div><div class="line">│  common_all.hpp   <span class="comment">//统一的主头文件(暂未生成)</span></div><div class="line">├─common            <span class="comment">//分头文件目录</span></div><div class="line">│  │  cmdline.hpp       <span class="comment">//命令行解析</span></div><div class="line">│  │  codecvt.hpp       <span class="comment">//字符编码转换</span></div><div class="line">│  │  cuda.hpp          <span class="comment">//cuda辅助(包含与opencv和directx的互操作)</span></div><div class="line">│  │  debuglog.hpp      <span class="comment">//windows调试日志</span></div><div class="line">│  │  opencl.hpp        <span class="comment">//opencl辅助</span></div><div class="line">│  │  opencv.hpp        <span class="comment">//opencv辅助(包含cuda重载版本)</span></div><div class="line">│  │  precomm.hpp       <span class="comment">//公共辅助</span></div><div class="line">│  │  windows.hpp       <span class="comment">//windows辅助(包含directx辅助)</span></div><div class="line">│  └─cuda           <span class="comment">//cuda设备函数目录</span></div><div class="line">│     │  texture_reference.cu</div><div class="line">│     └─ texture_reference.cuh</div><div class="line">├─docs              <span class="comment">//文档目录</span></div><div class="line">│  │  Doxyfile          <span class="comment">//doxygen生成配置文件</span></div><div class="line">│  └─html               <span class="comment">//文档网页根目录</span></div><div class="line">│     └─ index.html        <span class="comment">//文档入口</span></div><div class="line">├─samples           <span class="comment">//使用样例目录</span></div><div class="line">│  └─data               <span class="comment">//测试数据</span></div><div class="line">└─tests             <span class="comment">//单元测试目录</span></div><div class="line">   └─ tests_main.cpp    <span class="comment">//单元测试入口</span></div></div><!-- fragment --><hr/>
<h2>Macro</h2>
<p>默认关闭库/宏支持</p><ul>
<li><code>HAVE_OPENCL</code> //基于OpenCL 1.2</li>
<li><code>HAVE_OPENCV</code> //基于OpenCV 4.0 with contrib</li>
<li><code>HAVE_DIRECTX</code> //基于Microsoft DirectX SDK (June 2010)</li>
<li><code>HAVE_CUDA</code> //基于CUDA 10.0</li>
<li><code>HAVE_CUDA_KERNEL</code> // 本项目cuda目录下的.cu文件添加到工程后可以开启本宏,宏详细说明见<a class="el" href="common_2cuda_2_r_e_a_d_m_e_8md.html">common/cuda/README.md</a></li>
<li><code>LINK_LIB_OPENCV_WORLD</code> //opencv链接到opencv_world***.lib</li>
</ul>
<hr/>
<h2>Code style and code specification</h2>
<p><b>同一文件内应统一风格.</b></p>
<h3>命名</h3>
<ul>
<li>缩进应使用4空格而非制表符,语句后不应尾随空格.</li>
<li>简化匈牙利命名法:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">前缀  </th><th class="markdownTableHeadNone">类型   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">g_  </td><td class="markdownTableBodyNone">全局变量   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">m_  </td><td class="markdownTableBodyNone">类成员变量   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">s_  </td><td class="markdownTableBodyNone">静态变量   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">c_  </td><td class="markdownTableBodyNone">常量   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">p_  </td><td class="markdownTableBodyNone">指针变量   </td></tr>
</table>
<ul>
<li>所有前缀或后缀应该写在一起用一个下划线隔开:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">前后缀  </th><th class="markdownTableHeadNone">类型   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mp_  </td><td class="markdownTableBodyNone">成员指针变量   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mcp_  </td><td class="markdownTableBodyNone">成员常量指针   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mpc_  </td><td class="markdownTableBodyNone">成员指针常量   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_t  </td><td class="markdownTableBodyNone">结构体类型   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">_fn  </td><td class="markdownTableBodyNone">函数指针类型   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">_e  </td><td class="markdownTableBodyNone">枚举类型   </td></tr>
</table>
<ul>
<li>临时或局部变量可以加个下划线前缀.</li>
<li>文件/变量/命名空间等命名全小写+下划线.</li>
<li>命名空间/宏结束需要注释.</li>
<li>接口类以I开头或者Interface结尾.</li>
</ul>
<h3>文件</h3>
<ul>
<li>在<code><a class="el" href="common_8hpp.html">common.hpp</a></code>中进行分头文件的条件编译,而不是在头文件内部. 头文件在显式调用时不需要另外定义<code>HAVE_</code>形式的宏来开启整个头文件的功能.</li>
<li>源文件内的头文件包含顺序应从最特殊到一般,如： <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;通用头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;源文件同名头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;本模块其他头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;自定义工具头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;第三方头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;平台相关头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;C++库头文件&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;C库头文件&quot;</span></div></div><!-- fragment --></li>
<li>头文件中只用了指针/引用则使用前向声明而非引入头文件.</li>
<li>模块应使用命名空间<code>namespace{}</code>包含.</li>
<li>上下少空行,每屏代码越多越好.</li>
<li>如果需要设置编译警告,应将范围限制在本文件内 <div class="fragment"><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="preprocessor">#pragma warning( push ) //保存当前的编译状态</span></div><div class="line"><span class="preprocessor">#pragma warning( disable: 4127 )</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _MSC_VER</span></div><div class="line"><span class="preprocessor">#pragma warning( pop ) //恢复原先的状态</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></li>
<li>编译提示<ul>
<li>错误提示 ```cpp #error error 错误 123 ```</li>
<li>链接库文件时可以编译提示 ```cpp #pragma message("link opencv libs in opencv.hpp.") #pragma comment(lib,"opencv_core410.lib") ```</li>
</ul>
</li>
</ul>
<h4>HPP文件要注意的问题</h4>
<p>所有HPP文件使用宏避免重复包含. </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef _COMMON_PRECOMM_HPP_</span></div><div class="line"><span class="preprocessor">#define _COMMON_PRECOMM_HPP_</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>HPP文件中可以使用using引用依赖,不应该使用<code>using namespace</code>污染命名空间.</p>
<p>函数的重定义问题:</p><ul>
<li>将全局函数封装为类的静态方法.</li>
<li>通过冗余的模板参数变成模板函数. <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> flag=false&gt;</div></div><!-- fragment --></li>
<li>static修饰.</li>
<li>仿函数</li>
</ul>
<h3>Doxygen文档</h3>
<h4>注释</h4>
<div class="fragment"><div class="line">/**</div><div class="line"> *  多行注释</div><div class="line"> */</div><div class="line"></div><div class="line">/**单行注释*/ 或 ///</div><div class="line"></div><div class="line">/**&lt;同行注释 */ 或 ///&lt; (Doxygen认为注释是修饰接下来的程序代码的)</div></div><!-- fragment --><h4>文件信息</h4>
<div class="fragment"><div class="line">@file      文件名</div><div class="line">@author    作者名</div><div class="line">@version   版本号</div><div class="line">@todo      待办事项</div><div class="line">@date      日期时间</div><div class="line">@section   章节标题 e.g. [@section LICENSE 版权许可] [@section DESCRIPTION 描述]</div></div><!-- fragment --> <h4>模块信息</h4>
<div class="fragment"><div class="line">@defgroup   定义模块                         模块名(英文) 显示名    @{ 类/函数/变量/宏/... @}</div><div class="line">@ingroup    作为指定名的模块的子模块          模块名(英文) [显示名]</div><div class="line">@addtogroup 作为指定名的模块的成员            模块名(英文) [显示名]</div><div class="line">@name       按用途分,以便理解全局变量/宏的用途 显示名(中文)           @{ 变量/宏 @}</div></div><!-- fragment --><h4>函数信息</h4>
<div class="fragment"><div class="line">@brief     摘要</div><div class="line">@overload  重载标识</div><div class="line">@param     参数说明</div><div class="line">@param[in]      输入参数</div><div class="line">@param[out]     输出参数</div><div class="line">@param[in,out]  输入输出参数</div><div class="line">@return    返回值说明</div><div class="line">@retval    特定返回值说明 [eg:@retval NULL 空字符串][@retval !NULL 非空字符串]</div><div class="line">@exception 可能产生的异常描述</div><div class="line">@enum      引用了某个枚举,Doxygen会在引用处生成链接</div><div class="line">@var       引用了某个变量</div><div class="line">@class     引用某个类 [eg: @class CTest &quot;inc/class.h&quot;]</div><div class="line">@see       参考链接,函数重载的情况下,要带上参数列表以及返回值</div><div class="line">@todo      todo注解</div><div class="line">@pre       前置条件说明</div><div class="line">@par       [段落标题] 开创新段落,一般与示例代码联用</div><div class="line">@code      示例代码开始 e.g. [code{.cpp}]</div><div class="line">@ endcode  示例代码结束</div></div><!-- fragment --><h4>提醒信息</h4>
<div class="fragment"><div class="line">@note      注解</div><div class="line">@attention 注意</div><div class="line">@warning   警告</div><div class="line">@bug       问题</div><div class="line">@def       宏定义说明</div></div><!-- fragment --><h4>生成</h4>
<p>文档目录下执行<code>doxygen Doxyfile</code></p>
<h3>类/函数</h3>
<ul>
<li>应尽可能多的使用模板函数.</li>
<li>构造函数只进行没有实际意义的初始化,通过<code>Init()</code>,<code>Setup()</code>等函数进行具体构造.</li>
<li><code>Switch</code>中若default永不执行可以使用<code>assert(false)</code>.</li>
<li>不使用class类型全局对象,除非单例模式或者使用<code>unique_ptr</code>.</li>
<li><code>explicit</code>修饰单参数构造函数,防止隐式类型转换误用</li>
<li>尽可能使用<code>const</code></li>
<li>函数缺省参数,声明处缺省,定义处应该在形参列表使用注释标明缺省值<code>/**/</code></li>
<li>使用自动字符数组<code>autobuffer</code> <div class="fragment"><div class="line">std::vector&lt;char&gt; buffer(10);</div><div class="line">std::unique_ptr&lt;char[]&gt; buffer(<span class="keyword">new</span> <span class="keywordtype">char</span>[10]);</div></div><!-- fragment --></li>
</ul>
<h2>Summary of experience</h2>
<ul>
<li>编译期可以确定的常量应该使用<code>constexpr</code>修饰.</li>
<li><code>assert</code> 断言<ul>
<li>调试阶段函数开始前进行参数检查.发布版可关闭断言. ```cpp #define NDEBUG / /关闭断言 #include &lt;assert.h&gt; // #include &lt;cassert&gt; assert(p!=0) //若错误则终止程序执行 ```</li>
</ul>
</li>
<li><code>volatile</code> 易变修饰<ul>
<li>声明变量可能被系统,硬件或其他线程更改,而编译器不应该优化.**(不可优化的)**</li>
<li>每次取值必须从内存中取 (防止编译器优化从寄存器中取值).**(易变的)**</li>
<li><code>C/C++ Volatile</code>变量间的操作,编译器不会进行乱序优化.**(顺序的)**</li>
<li><code>const</code> 可以是<code>volatile</code>(如只读状态的寄存器).</li>
<li>指针可以是<code>volatile</code>.</li>
</ul>
</li>
<li><code>inline</code> 内联修饰<ul>
<li>相当于宏,比宏多了类型检查,运行时可调试(宏定义不能).</li>
<li>一般代码行数不多的函数(5行以内)可以建议编译器内联.</li>
<li>类内自动隐式内联.类外可以显式内联.</li>
<li>如果关闭优化,编译器可能会无视内联修饰符.</li>
</ul>
</li>
<li><code>explicit</code> 显式调用<ul>
<li>修饰构造函数 防止隐式转换和复制初始化.</li>
<li>修饰转换函数 防止隐式转换(按语境转换除外).</li>
</ul>
</li>
<li>后置返回类型(<code>trailing return type</code>)<ul>
<li>将返回类型移到参数声明后面. <code>-&gt;double</code>被称为后置返回类型. <code>auto</code>相当于占位符.后置返回类型有利于进行模板返回类型推导. ```cpp double h(int x, float y); // == auto h(int x, float y) -&gt; double;//C++14 开始可以推导返回类型 ```</li>
<li><p class="startli"><code>decltype</code>返回操作数的类型 ```cpp template &lt;typename t&gt;=""&gt; auto fun(T beg)-&gt;decltype(*beg){ return *beg;//返回引用 }</p>
<p class="startli">template &lt;typename t&gt;=""&gt; auto fun2(T beg)-&gt;typename std::remove_reference&lt;decltype(*beg)&gt;::type//移除引用,为了使用模板,参数成员必须使用typename { return *beg;//返回拷贝 } ```</p>
</li>
</ul>
</li>
<li><code>sizeof()</code><ul>
<li>对数组可得数组大小.</li>
<li>对指针可得指针本身所占空间大小.</li>
<li>对有静态变量的结构体.静态变量的存放位置与结构体实例的存储地址无关,是单独存放在静态数据区的,因此用<code>siezof</code>计算其大小时没有将静态成员所占的空间计算进来.</li>
<li>对于可变长参数包可得参数的数目,<code>sizeof…(Args)</code>.</li>
<li>基本数据类型所占内存大小</li>
</ul>
</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">类型  </th><th class="markdownTableHeadNone">32bit  </th><th class="markdownTableHeadNone">64bit   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">char , bool  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">short  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">int , unsigned int , float  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">long , void*  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">8   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">double , long long  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">8   </td></tr>
</table>
<ul>
<li><code>using</code> 声明<ul>
<li>引用命名空间 ```cpp using namespace name::name ```</li>
<li>引用命名空间的一个成员 ```cpp using std::cin; using std::cout; using std::endl; ```</li>
<li>构造函数的using声明 ```cpp //c++11中派生类能重用其直接基类定义的构造函数 class B:A{ public: using A::A; }; //如上using声明 //对于基类的每个构造函数,编译器都生成一个与之对应(形参列表完全相同)的派生类构造函数 B(param):A(args){} ```</li>
</ul>
</li>
<li><code>extern "C"{}</code><ul>
<li><p class="startli">按照C语言方式编译链接,避免因C++符号修饰导致代码不能和C语言库中的符号进行链接.如果都是cpp项目就不必要了. ```cpp #ifdef __cplusplus extern"C"{ #endif</p>
<p class="startli">#ifdef <b>cplusplus } #endif ```</b></p>
</li>
</ul>
</li>
<li><b><code>std::initializer_list</code> 列表初始化 <div class="fragment"><div class="line">std::vector&lt;T&gt; V;</div><div class="line">S(std::initializer_list&lt;T&gt; v):V(v){}</div><div class="line"></div><div class="line">S({1,2,3});</div></div><!-- fragment --></b></li>
<li><b><code>std::move</code><ul>
<li>将对象的状态或者所有权从一个对象转移到另一个对象,只是转移,没有内存的搬迁或者内存拷贝.</li>
<li><code>string</code>类在赋值或者拷贝构造函数中会声明<code>char</code>数组来存放数据,然后原<code>string</code>中的<code>char</code>数组会被析构函数释放,如果<code>x</code>是一个临时变量,则上面的拷贝,析构就是多余的,完全可以把临时变量<code>x</code>中的数据直接"转移"到新的变量下面. ```cpp std::string str = "Hello"; std::vector&lt;std::string&gt; v; //调用常规的拷贝构造函数,新建字符数组,拷贝数据 v.push_back(str); //调用移动构造函数,移动str,移动后不能使用str,因为转移后的值是未定义的. v.push_back(std::move(str)); ``<code></code></li>
<li><code>对外接口谨慎使用,需确保入参不会被再次调用.内部自己可控的可以使用</code>move<code>,因为</code>move<code>会移交控制权,外部可能会不知情.</code></li>
<li><code>编译器存在返回值优化,大部分时候直接</code>return<code>就行.除非</code>return<code>表达式是左值并且没有资格进行复制省略. </code>``cpp T bar(bool k) { T a, b; return k ? a : b; // 左值表达式,复制 return std::move(k ? a : b); // 移动 if (k) return a; // 移动,可能复制省略 else return b; // 移动,可能复制省略 } ``<code> 当</code>x<code>是局部变量时,返回</code>x<code>更好,因为编译器会将</code>x<code>视为返回值中的右值, 因为它知道</code>x<code>是本地变量.当</code>x<code>是引用时,编译器不会给它特殊处理. -</code>std::unique_ptr&lt;tt&gt;不能进行普通的拷贝和赋值操作但是可以使用std::move&lt;tt&gt;. ``cpp unique_ptr&lt;int&gt; pInt(new int(5)); unique_ptr&lt;int&gt; pInt2 = std::move(pInt);//转移所有权 ```</li>
</ul>
</b></li>
<li><b><code>std::forward</code><ul>
<li>完美转发实现了参数在传递过程中保持其值属性的功能,即若是左值,则传递之后仍然是左值,若是右值,则传递之后仍然是右值.</li>
<li><code>std::move</code>和<code>std::forward</code>本质都是转换.<code>std::move</code>执行到右值的无条件转换.<code>std::forward</code>只有在它的参数绑定到一个右值上的时候,才转换它的参数到一个右值.</li>
<li><code>std::move</code>没有<code>move</code>任何东西,<code>std::forward</code>没有转发任何东西.在运行期,它们没有做任何事情.它们没有产生1byte需要执行的代码.</li>
<li><code>std::forward&lt;T&gt;()</code>不仅可以保持左值或者右值不变,同时还可以保持<code>const</code>、<code>Lreference</code>、<code>Rreference</code>、<code>validate</code>等属性不变.</li>
</ul>
</b></li>
<li><b><code>deprecated</code>  弃用<ul>
<li>声明时未被弃用的名字可被重声明为<code>deprecated</code>,而声明为<code>deprecated</code>的名字不能通过重声明变为未弃用.</li>
<li><p class="startli">下列名字或实体的声明中允许使用这个属性: ```cpp class/struct/union：struct [[deprecated("Replaced by bar, which has an improved interface")]] S;</p>
<p class="startli">typedef名,也包括别名声明：[[deprecated]] typedef S* PS;using PS [[deprecated]] = S*;</p>
<p class="startli">变量,包括静态数据成员：[[deprecated]] int x;</p>
<p class="startli">非静态数据成员：union U { [[deprecated]] int n; };</p>
<p class="startli">函数：[[deprecated]] void f();</p>
<p class="startli">命名空间：namespace [[deprecated]] NS { int x; }</p>
<p class="startli">枚举：enum [[deprecated]] E {};</p>
<p class="startli">枚举项：enum { A [[deprecated]], B [[deprecated]] = 42 };</p>
<p class="startli">模板特化：template&lt;&gt; struct [[deprecated]] X&lt;int&gt; {}; ```</p>
</li>
</ul>
</b></li>
<li><b><code>noexcept</code><ul>
<li>编译器编译期间不会检查<code>noexcept</code>.</li>
<li>声明了<code>noexcept</code>却抛出异常时会直接调用<code>terminal</code>终止程序(外部将无法捕获异常).</li>
<li>就算没修饰<code>noexcept</code>,编译器也会自动推断有些函数不会抛出异常,除非编译器不能确定的情况, 例如重载移动赋值构造函数时(需要声明不会抛出异常).</li>
<li>编译器会对<code>noexcept</code>修饰的函数做优化.</li>
<li>若函数内部处理了异常,可以声明<code>noexcept</code>.</li>
<li>会抛出异常的函数应该声明为<code>noexcept(false)</code>.</li>
<li><code>noexcept(noexcept(!x.empty()))</code>可以进行条件判断(e.g.对形参进行断言),如果满足条件则承诺不会抛出异常.</li>
<li>编译器会自动为析构函数隐式加上<code>noexcept</code>.</li>
<li><code>noexcept</code>支持推导,而容器元素在支持右值引用的情况下这类推导是很重要的.右值引用可以减少深拷贝的需求,但是在某些情况下会破坏强异常安全保证.利用&lt;tt&gt;noexcept推导来决定一个复杂类型作为容器元素的时候到底适合用移动还是适合用普通的拷贝策略来保证强异常安全.比如一个类型如果不支持无异常的移动(自身或任一基类或者数据成员的移动构造函数声明了<code>noexcept(false)</code>),则推导这个类型不适合移动而只能使用拷贝实现异常安全.</li>
</ul>
</b></li>
<li><b>2次幂枚举量 <div class="fragment"><div class="line"><span class="keyword">enum</span> Days</div><div class="line">{</div><div class="line">    None = 0,</div><div class="line">    Sunday = 1,</div><div class="line">    Monday = 2,</div><div class="line">    Tuesday = 4,</div><div class="line">    Wednesday = 8,</div><div class="line">    Thursday = 16,</div><div class="line">    Friday = 32,</div><div class="line">    Saturday = 64</div><div class="line">};</div><div class="line"></div><div class="line">Days flag = Days::Monday;</div><div class="line"><span class="comment">//添加条件: |</span></div><div class="line">flag = Days(flag | Days::Wednesday);</div><div class="line"><span class="comment">//删除条件: &amp;~</span></div><div class="line">flag = Days(flag &amp; ~ Wednesday);</div><div class="line"><span class="comment">// &quot;flag&quot; 为 &quot;Monday&quot;</span></div><div class="line"><span class="keywordflow">if</span> ((flag &amp; Monday) == Monday) {cout &lt;&lt; <span class="stringliteral">&quot;Monday&quot;</span> &lt;&lt; endl;}</div><div class="line"><span class="comment">// &quot;flag&quot;  为&quot;Monday 与 Wednesday&quot;</span></div><div class="line"><span class="keywordflow">if</span> ((flag &amp; (Monday | Wednesday)) == (Monday | Wednesday)){cout &lt;&lt; <span class="stringliteral">&quot;Monday &amp; Wednesday&quot;</span> &lt;&lt; endl;}</div><div class="line"><span class="comment">// &quot;flag&quot; 为 &quot;Monday 或者 Wednesday&quot;</span></div><div class="line"><span class="keywordflow">if</span> ((flag &amp; (Monday | Wednesday)) != 0) {cout &lt;&lt; <span class="stringliteral">&quot;Monday | Wednesday&quot;</span> &lt;&lt; endl;}</div></div><!-- fragment --></b></li>
<li><b>不定长参数模板 <div class="fragment"><div class="line"><span class="comment">//用于结束递归的同名模板函数</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__common.html#ga56f35412e131481dd776367ce2d786f7">delete_s</a>(T&amp; p)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p != <span class="keyword">nullptr</span>) { <span class="keyword">delete</span>(p); p = <span class="keyword">nullptr</span>; }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//用于递归不定长参数的同名模板函数</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__common.html#ga56f35412e131481dd776367ce2d786f7">delete_s</a>(T&amp; p, Args&amp;... args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p != <span class="keyword">nullptr</span>) { <span class="keyword">delete</span>(p); p = <span class="keyword">nullptr</span>; }</div><div class="line">    <a class="code" href="group__common.html#ga56f35412e131481dd776367ce2d786f7">delete_s</a>(args...);</div><div class="line">}</div></div><!-- fragment --></b></li>
<li><p class="startli"><b>函数缓存</b></p>
<p class="startli"><b> 为了优化程序性能我们经常使用缓存,比如某个函数非常耗时,频繁调用的时候性能会很低,这时我们可以通过缓存来提高性能. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>detail {</div><div class="line">    <span class="comment">//函数入参及结果缓存,缓存入参和函数的执行结果,若入参存在则从缓存返回结果</span></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</div><div class="line">    std::function&lt;R(Args...)&gt; <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">cache_fn</a>(R(*func)(Args...))</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> result_map = std::make_shared&lt;std::map&lt;std::tuple&lt;Args...&gt;, R&gt;&gt;();</div><div class="line">        <span class="keywordflow">return</span> ([=](Args... args) {<span class="comment">//延迟执行</span></div><div class="line">            std::tuple&lt;Args...&gt; _args(args...);</div><div class="line">            <span class="keywordflow">if</span> (result_map-&gt;find(_args) == result_map-&gt;end()) {</div><div class="line">                (*result_map)[_args] = func(args...);<span class="comment">//未找到相同入参,执行函数刷新缓存</span></div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> (*result_map)[_args];<span class="comment">//返回缓存</span></div><div class="line">        });</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//函数对象缓存,若存在相同类型函数指针,则调用相应缓存函数获取缓存结果</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>...  Args&gt;</div><div class="line">std::function&lt;R(Args...)&gt; <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">cache_fn</a>(R(*func)(Args...), <span class="keywordtype">bool</span> flush = <span class="keyword">false</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> function_type = std::function&lt;R(Args...)&gt;;</div><div class="line">    <span class="keyword">static</span> std::unordered_map&lt;decltype(func), function_type&gt; functor_map;</div><div class="line">    <span class="keywordflow">if</span> (flush) {<span class="comment">//明确要求刷新缓存</span></div><div class="line">        <span class="keywordflow">return</span> functor_map[func] = <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">detail::cache_fn</a>(func);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (functor_map.find(func) == functor_map.end()) {</div><div class="line">        functor_map[func] = <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">detail::cache_fn</a>(func);<span class="comment">//未找到相同函数,执行函数刷新缓存</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> functor_map[func];<span class="comment">//返回缓存</span></div><div class="line">}</div></div><!-- fragment --><p> 函数缓存可以大幅提高递归类函数的性能 </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> fibonacci_1(<span class="keywordtype">size_t</span> n) {</div><div class="line">    <span class="keywordflow">return</span> (n &lt; 2) ? n : fibonacci_1(n - 1) + fibonacci_1(n - 2);</div><div class="line">}</div><div class="line"><span class="keywordtype">size_t</span> fibonacci_2(<span class="keywordtype">size_t</span> n) {</div><div class="line">    <span class="keywordflow">return</span> (n &lt; 2) ? n : <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">cache_fn</a>(fibonacci_2)(n - 1) + <a class="code" href="group__detail.html#gab2b8cbff7c0944ad7a63f4c94982cd04">cache_fn</a>(fibonacci_2)(n - 2);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">auto</span> t1 = <a class="code" href="group__common.html#gabedbb4ac121d9fc5d8c9b042a23b5a72">getFnDuration</a>(fibonacci_1)(35);<span class="comment">//47ms (为45时,为5000ms)</span></div><div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="group__common.html#gabedbb4ac121d9fc5d8c9b042a23b5a72">getFnDuration</a>(fibonacci_2)(35);<span class="comment">//0ms  (为1000时,为2ms)</span></div></div><!-- fragment --><p></b></p>
</li>
<li><b>自动推断数组大小 <div class="fragment"><div class="line"><span class="comment">//(unsigned需要放在前面)</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">unsigned</span> n,<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> arr(<span class="keyword">const</span> T (&amp;m)[n]) {</div><div class="line">    std::cout &lt;&lt; m;</div><div class="line">}</div></div><!-- fragment --></b></li>
<li><b>最简洁也是效率最高的单例模式的C++11实现 <div class="fragment"><div class="line">widget&amp; widget::get_instance() {</div><div class="line">    <span class="keyword">static</span> widget instance;</div><div class="line">    <span class="keywordflow">return</span> instance;</div><div class="line">}</div></div><!-- fragment --></b></li>
<li><b><code>std::numeric_limits</code> 查询算术类型的各种特性 <div class="fragment"><div class="line"><span class="preprocessor">#include&lt;limits&gt;</span></div><div class="line">std::numeric_limits&lt;double&gt;::infinity();<span class="comment">//返回正无穷大</span></div><div class="line">std::numeric_limits&lt;double&gt;::epsilon(); <span class="comment">//返回DBL_EPSILON 可用于浮点数精度比较1.0+DBL_EPSILON!=1.0</span></div><div class="line">std::numeric_limits&lt;double&gt;::max();     <span class="comment">//返回类型最大值</span></div><div class="line">std::numeric_limits&lt;double&gt;::min();     <span class="comment">//返回最小归一化正值</span></div><div class="line">std::numeric_limits&lt;double&gt;::lowest();  <span class="comment">//返回类型最小值(-max)</span></div><div class="line">std::numeric_limits&lt;double&gt;::round_error(); <span class="comment">//返回类型最大舍入误差</span></div></div><!-- fragment --></b></li>
<li><b>type_traits<ul>
<li><code>SFINAE</code> (Substitution failure is not an error). 当调用模板函数时编译器会根据传入参数推导最合适的模板函数. <div class="fragment"><div class="line"><span class="comment">//条件对象类型,若TI为std::string或char,则选择第一个类型.</span></div><div class="line"><span class="keyword">typename</span> std::conditional_t&lt;</div><div class="line">         std::is_same_v&lt;TI, std::string&gt; || std::is_same_v&lt;TI, char&gt;, </div><div class="line">         std::istringstream, std::wistringstream&gt; iss(arg);</div><div class="line"></div><div class="line"><span class="comment">//校验模板参数类型,若T为char或std::string则返回TA类型的值(特化)</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TA, <span class="keyword">typename</span> TW&gt;</div><div class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_same_v&lt;T, char&gt; || std::is_same_v&lt;T, std::string&gt;, TA&gt;::type <a class="code" href="group__common.html#ga82fbddf474a1f80cb484bb0f7890166c">tvalue</a>(TA a, TW) { <span class="keywordflow">return</span> a; };</div><div class="line"></div><div class="line"><span class="comment">//除了模板参数列表,也可以将条件控制放在形参列表</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TA, <span class="keyword">typename</span> TW&gt;</div><div class="line">TA <a class="code" href="group__common.html#ga82fbddf474a1f80cb484bb0f7890166c">tvalue</a>(<span class="keyword">typename</span> std::enable_if&lt;std::is_same_v&lt;T, std::string&gt;, T&gt;::type t, TA a, TW) { <span class="keywordflow">return</span> a; };</div></div><!-- fragment --></li>
</ul>
</b></li>
<li><b>关于<code>directx</code><ul>
<li><code>CopyResource</code>之后需要刷新否则容易导致黑屏(未成功获取数据) ```cpp ctx-&gt;CopyResource(); ctx-&gt;Flush(); ``<code></code></li>
<li><code>不同</code>device<code>之间的</code>texture<code>通过</code>SharedHandle<code>进行共享/拷贝. -</code>DX11<code>调试,检查D3D对象是否释放,以及内存是否泄漏.<ul>
<li>把d3d的device定义为debug模式:D3D11_CREATE_DEVICE_DEBUG`</li>
<li>为初始化了的D3D对象设置别名. ```cpp #include &lt;d3dcommon.h&gt; #pragma comment(lib, "dxguid.lib") D3D_SET_OBJECT_NAME_A(device.Get(), "in_device"); ``<code></code></li>
<li><code>调用</code>ReportLiveDeviceObjects()<code>. </code>``cpp Microsoft::WRL::ComPtr&lt;ID3D11Debug&gt; d3dDebug; HRESULT hr = pDevice-&gt;QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast&lt;void**&gt;(d3dDebug.GetAddressOf())); if (SUCCEEDED(hr)) { hr = d3dDebug-&gt;ReportLiveDeviceObjects(D3D11_RLDO_DETAIL); } ```<ul>
<li>IntRef是d3d内部的对象引用,Refcount是用户引用数量,只需要注意Refcount不为0的对象就可以了(除了ID3D11Device). ``` D3D11 WARNING: Live ID3D11Texture2D at 0x000001F8C837ABB0, Name: in_left, Refcount: 1, IntRef: 0 [ STATE_CREATION WARNING #425: LIVE_TEXTURE2D] ```</li>
</ul>
</li>
</ul>
</code></li>
</ul>
</b></li>
<li><b><code>关于<code>opencv</code><ul>
<li>建议不要分配静态或全局<code>GpuMat</code>变量,即依赖于它的析构函数.此类变量和CUDA上下文的销毁顺序未定义.如果之前已销毁CUDA上下文.则GPU内存释放函数将返回错误.</li>
<li><code>cv::UMat</code> , <code>cv::cuda::GpuMat</code> 有些时候需要手动<code>release</code>.</li>
</ul>
</code></b></li>
<li><b><code>关于<code>cuda</code><ul>
<li><code>__syncthreads</code>等提示未定义标识符,并不会影响编译.原因可能是先创建的cpp工程而后添加的cuda生成自定义文件,而非直接创建cuda工程.可以通过在依赖的头文件前`#define __CUDACC<code>(.cu源文件编译时会定义这个宏). -</code>&lt;&lt;&lt;&gt;&gt;&gt;`内核函数启动参数显示应输入表达式,只是因为VS2017无法正确识别cuda内核启动符号,代码实际是由NVCC编译器编译的,所以也是不影响编译. </li>
</ul>
</code></b></li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
